#!/usr/bin/env ruby

require 'optparse'
require 'fileutils'
require 'highline/import'
require 'parseconfig'
require 'themoviedb'
require 'mime/types'

module Prompt

  def Prompt.yesno(prompt = 'Continue?', default = false)
    a = ''
    s = default ? '[Y/n/s]' : '[y/N/s]'
    d = default ? 'y' : 'n'
    until %w[y n s].include? a
      a = ask("#{prompt} #{s} ") { |q| q.limit = 1; q.case = :downcase }
      a = d if a.length == 0
    end
    if a == 'y'; true elsif a == 's'; 'skip' else false end
  end

end

class Settings

  def initialize(path)
    @path = path
    if !File.exist?(path) then FileUtils.touch(path) end
    conf = YAML.load_file(path)
    @settings = conf ? conf : Hash.new
  end

  def get(key)
    @settings[key]
  end

  def set(key, value)
    @settings[key] = value
    File.open(@path, 'w') { |f| YAML.dump(@settings, f) }
  end

end


class Propre
  include Prompt

  def initialize(options)
    @options = options
    @settings = Settings.new("#{Dir.home}/.config/Propre/settings.yaml")
    if @settings.get('apikey').nil?
      puts "It's seem you did not set your TMDB API Key, please tell me:"
      @settings.set('apikey', STDIN.gets.chomp())
    end
    Tmdb::Api.key(@settings.get('apikey'))
    Tmdb::Api.language(@settings.get('locale') ? @settings.get('locale') : 'en')
  end

  def crawlDirectory(path)
    Dir.foreach(path) do |item|
      next if item == '.' or item == '..'
      # next if !@options[:dotfile] && !item.start_with?('.')
      if File.directory?(File.join(path, item))
        if @options[:recursive] then self.crawlDirectory(File.join(path, item)) end
      else
        self.searchMovieFromFile(File.join(path, item))
      end
    end
  end

  def searchMovieFromFile(file)
    @file = file
    filename = File.basename(file,File.extname(file))
    if @options[:videonly] && !video?(file)
      return
    end
    if !@options[:dotfile] && filename.start_with?('.')
      return
    end
    if @options[:sanitize] then filename = self.sanitize(filename) end
    @movies = Tmdb::Movie.find(filename)
    if self.confirm
      File.rename(file, File.join(File.dirname(file), self.format(@selected)))
    end
  end

  def confirm()
    @selected = false
    @movies.each do |movie|
      answer = Prompt.yesno("#{File.basename(@file)} -> #{self.format(movie)}")
      if answer === false; next ; elsif answer === 'skip'; puts "Skipping..."; return end
      @selected = movie
      break
    end
    if @selected then @selected end
  end

  def format(movie)
    year = !movie.release_date.empty? ? Date.strptime(movie.release_date, "%Y-%m-%d").year : false
    title = year ? "#{movie.title} (#{year})" : "#{movie.title}"
    title.gsub! ':','-'
    return "#{title}#{File.extname(@file)}"
  end

  def sanitize(filename)
    filename.downcase!
    filename.gsub!(/\(.*\)/, '').gsub!("_", ' ').gsub!(".", ' ').strip!
    warez = ["truefrench","fansub","bluray","720", "720p", "x264","french", "fr", "divx","hdcam","xvid","appz","bdrip","board","cam","dvd","dvd-r","dvdrip","dupecheck","fake","fs","gamez","hddvd","hddvdrip","hdrip","hdtv","pdtv","internal","int","keygen","leecher","limited","nuke","proper","repack","retail","rip","rip","screener","serial","subforced","hardsub","stv","telecine","telesync","tvrip","unrated","vhsrip","vo","vost","vostfr","workprint","french","wp","subbed","unsubbed", "r5", "r6", "md"]  
    (filename.split - warez).join(' ')
  end

  def video?(file)
    MIME::Types[/^video/].include? MIME::Types.of(file)
  end

end

options = {}
OptionParser.new do |opt|
  opt.banner = "Usage: #{ File.basename($0) } [OPTION]... SOURCE..."

  opt.on('-R', '--recursive', 'Run recursively') do |v|
    options[:recursive] = v
  end

  opt.on('-i', '--interactive', 'Run interactively') do |v|
    options[:interactive] = v
  end

  opt.on('-V', '--video-only', 'Search for video files only') do |v|
    options[:videonly] = v
  end

  opt.on('-s', '--sanitize', 'Sanitize filename before search') do |v|
    options[:sanitize] = v
  end

  opt.on('-d', '--dotfile', 'Don\'t ignore .dotfile') do |v|
    options[:dotfile] = v
  end

  options[:help] = opt.help
end.parse!

def main(options)
  if ARGV.size < 1
    puts options[:help]
  else
    propre = Propre.new(options)
    if File.directory?(ARGV[0])
      propre.crawlDirectory(ARGV[0])
    end

    if File.file?(ARGV[0])
      propre.searchMovieFromFile(ARGV[0])
    end
  end
end

begin
  main(options)
rescue Interrupt
  puts "\nExiting..."  
rescue StandardError => e
  puts e
end